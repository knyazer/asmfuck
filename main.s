# Brainfuck compiler, optimized
/* vim: set filetype=gas : */
# TODO: RLE compression optimization
# TODO: advanced compiling, loop isolation, writing intermediate code representation into separate files
# TODO: testing suite
# TODO: do not use C libraries, use only system calls
# TODO: read https://www.agner.org/optimize/
# P.S. I am a bit scared about fraud, as there were some huge parts of the code generated by Copilot, and it seems like it stole it from some repo on github, as suggestion were really elaborate and precise.
.text

more_than_one_arg_message: .asciz "\n\033[1;31mError: Please, provide exactly one file to be executed. Think about your actions. \033[0m\n"

cannot_read_file_message: .asciz "\n\033[1;31mError: Cannot read specified file. Might be a TYPO, might be something else, idk. Check everything once more. \033[0m\n"

cannot_read_from_stdin_message: .asciz "\n\033[1;31mError: Cannot read from stdin. Probably something wrong with your system, or the program, or idk. I have not idea how to fix this. \033[0m\n"

nothing_in_stdin_message: .asciz "\n\033[1;31mError: Nothing in stdin. This might be caused by some random stuff in your terminal, so you could try to change terminal, or rerun the program. Other than that, I have no idea how to help you. \033[0m\n"

incomplete_loop_message: .asciz "\n\033[1;31mError: Incomplete loop in the compressed brainfuck code. Either you have a problem with you brainfuck code, or something went really wrong with the compression algorithm. This error means that at the '[' the data pointer had 0 value, so we started to search for loop closing statement ']', but encountered the end of code before finding any. Really bad error. \033[0m\n"

RLE_placeholder: .asciz "%ld%c\n"

char_placeholder: .asciz "%c"

int_placeholder: .asciz "%d->"

delimiter: .asciz "\n\n---------------------------\n\n"

test_text: .asciz "tests/hello.b"

.global main

main:
    pushq %rbp              # Push base pointer to stack
    movq %rsp, %rbp         # Base pointer = stack pointer 
    
    subq $0x100000, %rsp    # Allocate 1 MB of memory on stack
    # The structure of stack is decently simple:
    # --------------------------------------------------   <- %rbp
    # some local vars & thingies
    # --------------------------------------------------   <-  -24(%rbp) + 30000 = %rbp - 64
    # brainfuck memory space (30 KiB)
    # --------------------------------------------------   <-  -24(%rbp)
    # empty space
    # --------------------------------------------------   <-  -32(%rbp)
    # RLE compressed brainfuck code 
    # block structure:
    # [4 bytes for number of reps]
    # [1 byte for command]
    # [3 byte for padding]
    # --------------------------------------------------   <-  -16(%rbp)
    # Raw brainfuck code (string)
    # --------------------------------------------------   <-  %rsp
    # end
    # 
    #
    # Some useful addresses:
    # -8(%rbp) - file descriptor
    # -16(%rbp) - pointer to the highest address with brainfuck code (end of the code)
    # -24(%rbp) - pointer to the lowest address of brainfuck memory space (beginning of it, size 30KiB)
    # -32(%rbp) - pointer to the highest address of the RLE compressed brainfuck code (end of it)
    # %rsp - pointer to the lowest address with brainfuck code (beginning of the code)
    
    # Setup brainfuck memory pointer, temporary register rax
    movq %rbp, %rax # CHANGE THE SIZE OF MEMO 
    subq $30064, %rax     # 30064 = 30000 + 64, 64 is the size of the local vars block
    movq %rax, -24(%rbp)
    
    # Put brainfuck memory end at %r10
    movq %rbp, %r10
    subq $64, %r10

    # Zerofy brainfuck memory
zerofy_memory:
    movq $0, (%rax)
    addq $8, %rax
    cmpq %rax, %r10 # Iterate until %rax == brainfuck memory end
    jne zerofy_memory


    # Check that there is exactly one argument (argc = 2, first one is something like path or number, whatever)
    cmpq $2, %rdi
    jne more_than_one_arg

    # Read the file
    movq 8(%rsi), %rdi  # 8(%rsi) is the second argv, which is the first argument provided, which is filename
    movq $2, %rax       # Open flag
    movq $0, %rsi       # Read only mode probably, idk
    syscall

    movq %rax, -8(%rbp)     # Save file descriptor to local variable

    # Read the file
    # Temporary store the pointer to the current brainfuck code end in the %r8
    movq %rsp, %r8

read_block:
    movq $128, %rdx         # Size of block to read
    movq $0, %rax           # Read flag
    movq -8(%rbp), %rdi     # File descriptor
    movq %r8, %rsi         # Address of the buffer
    syscall

    addq %rax, %r8          # Update the brainfuck code end pointer
    cmp $0, %rax            # Check if the file is over
    jl cannot_read_file    # if rax < 0, then syscall failed, and we want to show this #!DEBUG
    jne read_block          # If not, read another block

    # If it is, then save the pointer to the end of the brainfuck code
    movq %r8, -16(%rbp)
    
    # And here we are, now we have a brainfuck program lying in the end of the stack
    
    # Let's now compress the program, using RLE compression.

    # The block structure is as follows:
    # [4 bytes] - number of repetitions
    # [1 byte] - command
    # [3 bytes] - reserved (padding to 8 bytes)
    
    # Lets store current compressed program pointer in the %r8, and current raw program pointer in the %r9
    # %r8 is already set to the correct value, so set only %r9
    movq %rsp, %r9
    
add_new_block:
    movq $0, (%r8)            # Clear the value of the first block
    
    # Copy the raw command to the compressed program
    movb (%r9), %r10b
    movb %r10b, 4(%r8)

move_raw_pointer:
    incl (%r8)             # Increment the number of repetitions
    inc %r9                 # Move to the next raw command
    
    movb (%r9), %r10b       # Save the current command to temporary register
    cmpq -16(%rbp), %r9     # Check if we are at the end of the raw program
    
    je finish_RLE           # If we are, then finish the compression
    
    # We want to have only singular [ or ] in the blocks of compressed program, as it makes readability better, and execution much less complicated, though overall almost not affecting anything else

    cmpb $'[', %r10b        # Check if the current command is [
    je RLE_loop_last_step        # If it was, then move to the next block, ignoring repetitions
    
    cmpb $']', %r10b        # Check if the current command is ]
    je RLE_loop_last_step        # If it was, then move to the next block, ignoring repetitions

    cmpb 4(%r8), %r10b      # Otherwise, compare the current command with the previous one
    je move_raw_pointer     # If they are the same, then move to the next one

RLE_loop_last_step:
    # If they are not, then we need to add new block
    addq $8, %r8
    jmp add_new_block

finish_RLE:
    # Firstly, align the last pointer properly 
    addq $8, %r8
    # Save the current RLE program end pointer to the stack
    movq %r8, -32(%rbp)

    # Now, we have the RLE compressed program lying in the stack, and we can print it, for debugging purposes
    
    movq -16(%rbp), %rbx    # Store pointer to the current block in rbx, as it is callee saved
    
looping_around_for_RLE_printing:
    movq $0, %rax           # Printf flag, no SIMD
    movq $RLE_placeholder, %rdi # Printf format string
    movq $0, %rsi           # Zerofy the rsi register
    movl (%rbx), %esi       # Number of repetitions
    movq $0, %rdx           # Zerofy the rdx register
    movb 4(%rbx), %dl      # Command
    call printf
    
    addq $8, %rbx          # Move to the next block
    cmpq -32(%rbp), %rbx   # Check that we are not at the end of the RLE program
    jne looping_around_for_RLE_printing
    
    # Print delimiter
    movq $0, %rax
    movq $delimiter, %rdi
    call printf

    # Now, we can execute the program
    # Lets define some registers:
    # %r12 - pointer to the current code block
    # %r13 - brainfuck memory pointer
    movq -16(%rbp), %r12
    movq -24(%rbp), %r13
    
looping_around_for_execution:
    # zerofi temprorary registers
    movq $0, %r10
    movq $0, %rdi
    
    # Put the command and number of repetitions into separate temporary registers, %r10b and %edi
    movb 4(%r12), %r10b
    movl (%r12), %edi
    # GDB command to debug: printf "%ld %c, bmem value: %ld, bmem_ptr: %ld \n\n", $rdi, $r10, *(uint64_t*)$r13, $r13 - *(uint64_t*)($rbp-24)
    # A huge if else statement, which executes the command
    cmpb $'+', %r10b
    je bf_add

    cmpb $'-', %r10b
    je bf_sub

    cmpb $'>', %r10b
    je bf_right

    cmpb $'<', %r10b
    je bf_left

    cmpb $'.', %r10b
    je bf_print

    cmpb $',', %r10b
    je bf_read

    cmpb $'[', %r10b
    je bf_loop_start

    cmpb $']', %r10b
    je bf_loop_end

    # If we are here, then we have an unknown command, which we just ignore
    jmp if_else_end_for_execution
    
    # Here are the definitions of brainfuck commands
bf_add:
    addb %dil, (%r13)
    jmp if_else_end_for_execution
    
bf_sub:
    subb %dil, (%r13)
    jmp if_else_end_for_execution

bf_right:
    addq %rdi, %r13
    jmp if_else_end_for_execution

bf_left:
    subq %rdi, %r13
    jmp if_else_end_for_execution

bf_print:
    movq %rdi, %r15 # r15 as counter as rdi used
bf_print_loop:
    # Printf corrupts, but we kinda do not care, as all important things are callee saved
    movq $0, %rax # No SIMD
    movq $char_placeholder, %rdi # string to output
    movq $0, %rsi # zerofy rsi to remove noise
    movb (%r13), %sil # value to output
    call printf
        
    decq %r15
    cmp $0, %r15
    jne bf_print_loop

    jmp if_else_end_for_execution
    
bf_read:
    # While it seems inadequate, our compressed version should be always the same as uncompressed, so we repeat reading char the required number of times. 
        
    # Counter is in %rdi (%edi to be exact), which we use, so move it to %r15
    movq %rdi, %r15
bf_read_loop:
    movq $0, %rax           # Read flag
    movq $0, %rdi           # stdin file descriptor
    movq $2, %rdx           # max size
    subq $16, %rsp          # Allocate two bytes for temporary storage of the read value
    # when we read something the first char is what we need, and the second one is \n which we ignore
    movq %rsp, %rsi         # Address of the buffer

    syscall
    
    movb (%rsp), %al      # Move the read value to the temporary register
    movb %al, (%r13)       # Load value from the temporary register to the brainfuck memory
    addq $16, %rsp          # Deallocate the temporary storage
    
    cmpq $0, %rax           # Check if everything works as expected
    jl cannot_read_from_stdin # If there is an error, show error message and exit
    je nothing_in_stdin     # If there is nothing in stdin, show error message and exit (hmm?)
    
    decq %r15               # Decrement the counter
    cmpq $0, %r15           # Check if we are done
    jne bf_read_loop        # If we have not read all the chars, then read the next one

    jmp if_else_end_for_execution

bf_loop_start:
    cmpb $0, (%r13)         # Check if the current memory cell is zero
    je bf_search_for_loop_end_start   # If it is, iterate to the end of the loop without executing anything
    pushq %r12                  # If it is not, push the current brainfuck instruction pointer
    pushq %r12
    jmp if_else_end_for_execution # and continue execution

bf_loop_end:
    cmpb $0, (%r13)         # Check if the current memory cell is zero
    je pop_the_pointer_to_the_loop_start # If it is, then pop the pointer and continue main loop
    movq (%rsp), %r12               # If it is not, then set current instruction pointer to the saved one
    jmp if_else_end_for_execution # and continue execution
    
pop_the_pointer_to_the_loop_start:
    addq $16, %rsp
    jmp if_else_end_for_execution

# Here is the code for searching the corresponding closing bracket
bf_search_for_loop_end_start:
    # The preparation step is to set %r15, which is a counter for brackets, to 1 (as it is single opening bracket)
    movq $1, %r15
bf_search_for_loop_end:
    addq $8, %r12           # Move to the next block
        
    ### DEBUG! ###
    cmpq -32(%rbp), %r12    # Check if we are at the end of the program
    je incomplete_loop      # If we are, then something is really wrong -> show error message
    ### DEBUG! ###

    # Count all the brackets, when the sum is 0 - we found the end of the loop
    cmpb $']', 4(%r12) 
    je brackets_counter_dec
    cmpb $'[', 4(%r12)
    je brackets_counter_inc
        
    # If we are here, the current block is not a bracket, so repeat the cycle
    jmp bf_search_for_loop_end

brackets_counter_dec:
    decq %r15
    jmp bf_search_for_loop_end_sum_check

brackets_counter_inc:
    incq %r15
    jmp bf_search_for_loop_end_sum_check

bf_search_for_loop_end_sum_check:
    cmpq $0, %r15          # Check if the sum is 0, if so - we have found the end of the loop, ignoring all nested
    jne bf_search_for_loop_end # If it is not, then continue searching
    jmp if_else_end_for_execution # If it is, then continue execution (to the next block, so ignore the close loop command)
    jmp if_else_end_for_execution # If it is, then continue execution (to the next block, so ignore the close loop command)
    
### IMPORTANT ###
# Design decision for loops is that we store pointers to the opening brackets in the stack, pushing them to it and popping from it. 
# This allows to quickly jump back and forth between the brackets, and also allows to have nested loops.

if_else_end_for_execution:
    addq $8, %r12         # Move to the next block
    cmpq -32(%rbp), %r12   # Check if we are at the end of the program
    jne looping_around_for_execution # If not, then continue to the next block

    # If we are at the end of RLE compressed brainfuck code, then we are done

    # Clean up the stack
    movq %rbp, %rsp
    popq %rbp

    jmp end

# Different variants of how we can exit

end:
    movq $0, %rdi
    call exit

fail:
    movq $1, %rdi
    call exit

# Some error messages

more_than_one_arg:
    movq $0, %rax
    movq $more_than_one_arg_message, %rdi
    call printf
    jmp fail

cannot_read_file:
    movq $0, %rax
    movq $cannot_read_file_message, %rdi
    call printf
    jmp fail

cannot_read_from_stdin:
    movq $0, %rax
    movq $cannot_read_from_stdin_message, %rdi
    call printf
    jmp fail

nothing_in_stdin:
    movq $0, %rax
    movq $nothing_in_stdin_message, %rdi
    call printf
    jmp fail

incomplete_loop:
    movq $0, %rax
    movq $incomplete_loop_message, %rdi
    call printf
    jmp fail

### NOT USED ###

# Example of how to use system calls to print something
print_without_c:
    mov     $1, %rax                # system call 1 is write
    mov     $1, %rdi                # file handle 1 is stdout
    mov     $test_text, %rsi          # address of string to output
    mov     $13, %rdx               # number of bytes
    syscall   
