###################################### BRAINFUCK MAIN FILE #########################

# Brainfuck compiler, optimized
/* vim: set filetype=gas : */
# TODO: advanced compiling, loop isolation, writing intermediate code representation into separate files
# TODO: testing suite
# TODO: do not use C libraries, use only system calls
# TODO: read https://www.agner.org/optimize/
# TODO: RLE compression optimization
# TODO: Make faster iterating when 0 encountered at loop start
# P.S. I am a bit scared about fraud, as there were some huge parts of the code generated by Copilot, and it seems like it stole it from some repo on github, as suggestion were really elaborate and precise.
.global brainfuck

.text

more_than_one_arg_message: .asciz "\n\033[1;31mError: Please, provide exactly one file to be executed. Think about your actions. \033[0m\n"

cannot_read_file_message: .asciz "\n\033[1;31mError: Cannot read specified file. Might be a TYPO, might be something else, idk. Check everything once more. \033[0m\n"

cannot_read_from_stdin_message: .asciz "\n\033[1;31mError: Cannot read from stdin. Probably something wrong with your system, or the program, or idk. I have not idea how to fix this. \033[0m\n"

nothing_in_stdin_message: .asciz "\n\033[1;31mError: Nothing in stdin. This might be caused by some random stuff in your terminal, so you could try to change terminal, or rerun the program. Other than that, I have no idea how to help you. \033[0m\n"

incomplete_loop_message: .asciz "\n\033[1;31mError: Incomplete loop in the compressed brainfuck code. Either you have a problem with you brainfuck code, or something went really wrong with the compression algorithm. This error means that at the '[' the data pointer had 0 value, so we started to search for loop closing statement ']', but encountered the end of code before finding any. Really bad error. \033[0m\n"

RLE_placeholder: .asciz "%ld%c"

char_placeholder: .asciz "%c"

found_a_leaf_message: .asciz "\n Found a leaf! \n"

int_placeholder: .asciz "%d->"

delimiter: .asciz "\n\n---------------------------\n\n"

test_text: .asciz "\n test - test \n"

# The perfomace profiler I prefer is callgrind + kcachegrind
# The way you use them is to firstly run
# valgrind --tool=callgrind --dump-instr=yes --simulate-cache=yes --collect-jumps=yes ./main tests/mandelbrot.b
# and then
# kcachegrind callgrind.out.*
# then navigate to source code tab to the right, and there will be your assembly code with lr meaning percent of whole program time spent on this instruction, probably

# The benchmarking can be done via 
# time ./main tests/manelbrot.b
# the std is 0.25 seconds, so if your version differs by more than 0.8 seconds, that means your version is faster. if less - than it means it is the same. if it is slower by more than 0.8 seconds, that means your version is slower

# The list of operations:
# > - increment data pointer
# < - decrement data pointer
# + - increment value at data pointer
# - - decrement value at data pointer
# . - output value at data pointer
# , - input value at data pointer
# [ - jump to matching ] if value at data pointer is 0
# ] - jump to matching [ if value at data pointer is not 0
# ( - set mark to data pointer
# ) - set 0 to marked value
# ! - set 0 to value at data pointer
# * - add the marked value (multiplied by the number of repetetions) to value at data pointer
# / - subtract the marked value (multiplied by the number of repetitions) from value at data pointer
# a - add the marked value to value at data pointer only once
# s - subtract the marked value from value at data pointer only once
# $ - end of the pogram

brainfuck:
    # these two lines are for loading the argv and argc without stdlib
    #popq %rdi
    #movq %rsp, %rsi
    
    # Save registers
    pushq %rbx
    pushq %rbx
    pushq %r12
    pushq %r13
    pushq %r14
    pushq %r15

    pushq %rbp              # Push base pointer to stack
    movq %rsp, %rbp         # Base pointer = stack pointer 
    
    subq $0x80000, %rsp    # Allocate 2 MB of memory on stack
    # The structure of stack is decently simple:
    # --------------------------------------------------   <- %rbp
    # some local vars & thingies
    # --------------------------------------------------   <-  -24(%rbp) + 30000 = %rbp - 64
    # brainfuck memory space (30 KiB)
    # --------------------------------------------------   <-  -24(%rbp)
    # empty space
    # --------------------------------------------------   <-  -32(%rbp)
    # RLE compressed brainfuck code 
    # block structure:
    # [4 bytes for number of reps]
    # [1 byte for command]
    # [3 byte for padding]
    # --------------------------------------------------   <-  -16(%rbp)
    # Raw brainfuck code (string)
    # --------------------------------------------------   <-  %rdi
    # end
    # 
    # --------------------------------------------------   <-  -48(%rbp)
    # compiled brainfuck code
    # --------------------------------------------------   <-  -40(%rbp)
    # 
    #
    # Some useful addresses:
    # -8(%rbp) - file descriptor
    # -16(%rbp) - pointer to the highest address with brainfuck code (end of the code)
    # -24(%rbp) - pointer to the lowest address of brainfuck memory space (beginning of it, size 30KiB)
    # -32(%rbp) - pointer to the highest address of the RLE compressed brainfuck code (end of it)
    # %rsp - pointer to the lowest address with brainfuck code (beginning of the code)
    
    # Setup brainfuck memory pointer, temporary register rax
    movq %rbp, %rax
    subq $30064, %rax     # 30064 = 30000 + 64, 64 is the size of the local vars block
    movq %rax, -24(%rbp)
    movq %rsp, -16(%rbp)
    
    # And here we are, now we have a brainfuck program lying in the end of the stack
    
    # Let's now compress the program, using RLE compression.

    # The block structure is as follows:
    # [4 bytes] - number of repetitions
    # [1 byte] - command
    # [3 bytes] - reserved (padding to 8 bytes)
    # rdi has not changed yet
    movq -16(%rbp), %rsi  # Pointer to the beginning of the rle compressed code
    call rle_encode
    movq %rax, -32(%rbp)  # Save the pointer to the end of the rle compressed code
    
#jmp NO_LO 
    # First parameter is the address of RLE compressed program
    movq -16(%rbp), %rdi
    call leaf_optimization
NO_LO:
#jmp NO_COMPILATION
    # Now lets compile the thingy
    # First of all, allocate a huuuge chunk of memory for the compiled code via malloc
    movq -32(%rbp), %rdi
    subq -16(%rbp), %rdi
    movq $24, %rax
    mulq %rdi
    movq %rax, %rdi
    addq $0x8000, %rdi
    call malloc
    movq %rax, -40(%rbp)  # Save the pointer to the beginning of the compiled code

    # rdi - address of first block, rsi - address of the output
    movq -16(%rbp), %rdi
    movq -40(%rbp), %rsi
    call compile_to_string
    movq %rax, -48(%rbp)  # Save the pointer to the end of the compiled code

    # Calculate the length of the string:
    movq -48(%rbp), %rsi
    movq -40(%rbp), %rax
    subq %rax, %rsi
    # First parameter is the address
    movq -40(%rbp), %rdi
    call compile_from_string

    # Deallocate memo
	movq -40(%rbp), %rdi
	call free

    # Check if the rax is 0, if so - exit
    cmpq $0, %rax
    je end
NO_COMPILATION:
    #movq $1, %rax           # Write flag
    #movq $1, %rdi           # stdout file descriptor
    #leaq -2000000(%rbp), %rsi         # pointer to the string
    #syscall

#looping_around_for_RLE_printing:
#    movq $0, %rax           # Printf flag, no SIMD
#    movq $RLE_placeholder, %rdi # Printf format string
#    movq $0, %rsi           # Zerofy the rsi register
#    movl (%rbx), %esi       # Number of repetitions
#    movq $0, %rdx           # Zerofy the rdx register
#    movb 4(%rbx), %dl      # Command
#    call printf
#    
#    addq $8, %rbx          # Move to the next block
#    cmpq -32(%rbp), %rbx   # Check that we are not at the end of the RLE program
#    jne looping_around_for_RLE_printing
#    
#    # Print delimiter
#    movq $0, %rax
#    movq $delimiter, %rdi
#    call printf

# Now, here is the most complex part of the program: loop optimization
# The idea is decently simple: the majority of the time spent in the program is in the loops, so we want to optimize them as much as possible. 
# The idea is to move the plus-minus instructions outside of the loop
# For example, here is a simple loop of moving value from one cell to another:
# [->+<]
# We want to move the + outside of the loop, so it will look like this:
# counter = *0
# *1 += counter
# *0 = 0
# There are some important properties that must be met:
# 1. Counter is in the same place always. This could be checked by counting all the arrows in the loop, and if their sum is 0, then the counter is in the same location. 
# 2. No nested loops, as loops allow arbitrary pointer movement, and we cannot predict where the counter will be after the iteration.
# 3. No input in the loop, as input introduces uncertainty.
# 4. Only single decrement of the loop counter. Otherwise - weird things could happend, so we don't want to deal with them (like overflow properties are not clearly defined, etc).
# That is all. Also, the interesting fact is that we can optimize loops partially:
# Consider the loop [->+<] again. We can unpack the loop using following technique:
# (/>*<)
# \ equivalent to *ptr -= *(value when passing closest parentheses behind)
# * equivalent to *ptr += *(value when passing closest parentheses behind)
# ) set value at the corresponding parentheses to 0
# Now, suppose we have nested loops:
# We apply optimization to the bottommost loop [->+(/>*<)<]
# It works fine, but can we apply optimization to the parent loop? I think that we can, but it is complicated. 
# Probably we can isolate parts which do not depend on the memory state from the dependent ones(actually, only () and [])
# Some other notes: if we encounter loop [-] we can quickly replace it to just set 0, as it is a common alogrithm in the brainfuck code. Use 0 instruction then
# 0 instruction is allowed to be optimized. Setting the variable to 0 do not introduce any dependency on data, so it completely fine to use it. The optimized version of 0 instruction is same 0, which means that efficient brainfuck programs will not ever do that. Indeed, while to reset variable to 0 in the loop, if after the first iteration it will be already resat? However, just in case, include 0 instruction. 
### IMP: the 0 instruction is denoted by '!' to be consistent with RLE representation


# Some thoughts:
# The optimization of this sort can be considered basic, as they use the fact that the things inside brainfuck loop do not depend on the memory state at all.
# So, whatever is inside the loop, it does not have any dependency on the previous iteration, thus we should be able to apply 'perfect' parallelization to it.
# In case of basic instructions (standart brainfuck syntax), we can parallelize them with multiplication. The problems start from this point, as 
# the loops which has nested 'optimized' loop inside them introduce a data dependency: indeed, loops are dependent on its corresponding counter.
# Now we have a problem: how to parallelize loops with data dependency?
# Suppose we have a loop [ first-instr-block (optimized-loop) second-instr-block ]. (there are no loops of any kind in the instruction blocks).
# We can parallelize the basic-syntax-instructions, but what about the optimized-loop?
# Lets ignore it for now, and focus on the optimization of partially-optimizable loops, like provided in the example above. 
# The representation would be: optimized(first-instr-block) [ X ] optimized(second-instr-block)
# In X we want to include all operations happening with the location corresponding to the counter of the nested loop. 
# This allows as to move second block to the beginning, as the instructions from there do not affect the counter, and we can move them outside of the loop.
# Now the structure is: optimized(first-instr-block) optimized(second-instr-block) [ first-ops-with-the-X-counter X last-ops-with-the-X-counter this-loop-counter-change ] . 
# IMPORTANT: Condition: the only operation made on the parent loop counter is single decrement.

# This stage of optimization of the not nested loops is called leaf optimization, as these loops in the tree of loops are the leaves.

    # skip the output, because we don't need it for release
    # remove the next line if you want to look to the code
    jmp RLE_show_debug_end
    movq -16(%rbp), %rbx    # Store pointer to the current block in rbx, as it is callee saved
looping_around_for_RLE_printing:
    movq $0, %rax           # Printf flag, no SIMD
    movq $RLE_placeholder, %rdi # Printf format string
    movq $0, %rsi           # Zerofy the rsi register
    movl (%rbx), %esi       # Number of repetitions
    movq $0, %rdx           # Zerofy the rdx register
    movb 4(%rbx), %dl      # Command
    call printf

    cmpb $'[', 4(%rbx)
    je skip_next_block
    cmpb $']', 4(%rbx)
    je skip_next_block
    cmpb $'(', 4(%rbx)
    je skip_next_block
    cmpb $')', 4(%rbx)
    je skip_next_block

    jmp not_skip_next_block
skip_next_block:
    addq $8, %rbx
not_skip_next_block:
    addq $8, %rbx          # Move to the next block
    cmpq -32(%rbp), %rbx   # Check that we are not at the end of the RLE program
    jne looping_around_for_RLE_printing
    
    # Print delimiter
    movq $0, %rax
    movq $delimiter, %rdi
    call printf
RLE_show_debug_end:

    # Put brainfuck memory end at %r10
    movq %rbp, %r10
    subq $64, %r10

    # Zerofy brainfuck memory
    movq -24(%rbp), %rax
zerofy_memory:
    movq $0, (%rax)
    addq $8, %rax
    cmpq %rax, %r10 # Iterate until %rax == brainfuck memory end
    jne zerofy_memory

# And finally, start the interpretation
start_the_execution:
    movq -16(%rbp), %rbx    # Store pointer to the current block in rbx, as it is callee saved
    
    # Now, we can execute the program
    # Lets define some registers:
    # %r12 - pointer to the current instruction block
    # %r13 - brainfuck memory pointer
    # %r14 - number of repetitions for current optimized loop
    movq -16(%rbp), %r12
    movq -24(%rbp), %r13
    # subtract block size from r12, as we will be adding it in the loop
    subq $8, %r12
looping_around_for_execution:
    addq $8, %r12         # Move to the next block

    # Put the command into the r10 register, and pad it with zeros
    movzxb 4(%r12), %r10
    # GDB command to debug: printf "%ld %c, bmem value: %ld, bmem_ptr: %ld \n\n", $rdi, $r10, *(uint64_t*)$r13, $r13 - *(uint64_t*)($rbp-24)
    # Jump to the correct command
    shlq $3, %r10
    movq jumptable(%r10), %r10
    jmp *%r10
    
    # If we are here, then we failed somehow, but as it was not fatal, then just continue pretending nothing happened
    jmp looping_around_for_execution
    
    # Here are the definitions of complex brainfuck commands
bf_complex_start:
    addq $8, %r12 # Increment the instruction pointer anyways, so now it points to the loop end address
    movzxb (%r13), %r14 # Save the current data pointer to specific register
    cmpb $0, %r14b        # Check if the current memory cell is zero
    jne looping_around_for_execution # If not - continue execution
    movq (%r12), %r12
    addq $8, %r12 # Move the pointer to the instruction after the loop end
    jmp looping_around_for_execution # and continue execution

bf_complex_end:
    # nothing to do here
    jmp looping_around_for_execution

bf_complex_mul:
    movl (%r12), %edi
    # current_cell += counter * repetitions
    movq %rdi, %rax     # Move the number of repetitions to rax
    mul %r14          # Multiply it by the counter
    add %rax, (%r13)    # Add it to the current cell
    jmp looping_around_for_execution

bf_complex_sub_mul:
    movl (%r12), %edi
    # current_cell -= counter * repetitions
    movq %rdi, %rax     # Move the number of repetitions to rax
    mul %r14          # Multiply it by the counter
    sub %rax, (%r13)    # Subtract it from the current cell
    jmp looping_around_for_execution

bf_complex_zero:
    movb $0, (%r13)
    jmp looping_around_for_execution

bf_complex_single_mul:
    addb %r14b, (%r13)
    jmp looping_around_for_execution

bf_complex_sub_single_mul:
    subb %r14b, (%r13)
    jmp looping_around_for_execution

bf_complex_exit:
    jmp post_execution
    # Here are the definitions of normal brainfuck commands
bf_add:
    movl (%r12), %edi
    addb %dil, (%r13)
    jmp looping_around_for_execution
    
bf_sub:
    movl (%r12), %edi
    subb %dil, (%r13)
    jmp looping_around_for_execution

bf_right:
    movl (%r12), %edi
    addq %rdi, %r13
    jmp looping_around_for_execution

bf_left:
    movl (%r12), %edi
    subq %rdi, %r13
    jmp looping_around_for_execution

bf_print:
    movq $0, %r15
    movl (%r12), %r15d # Counter is the number of repetitions
bf_print_loop:
    # Printf corrupts, but we kinda do not care, as all important things are callee saved
    
    movq $1, %rax           # Write flag
    movq $1, %rdi           # stdout file descriptor
    movq $1, %rdx           # Write one byte
    subq $16, %rsp          # Allocate two bytes for temporary storage of the read value
    movq $0, (%rsp)         # zerofy the temporary storage
    movq $0, 8(%rsp)        # zerofy the temporary storage
    movb (%r13), %cl       # value to temp
    movb %cl, (%rsp)       # char to show
    movq %rsp, %rsi         # pointer to the string
    syscall
    addq $16, %rsp          # Deallocate the temporary storage

    # when we read something the first char is what we need, and the second one is \n which we ignore
    movq %rsp, %rsi         # Address of the buffer
    decq %r15
    cmp $0, %r15
    jne bf_print_loop

    jmp looping_around_for_execution
    
bf_read:
    # While it seems inadequate, our compressed version should be always the same as uncompressed, so we repeat reading char the required number of times. 
        
    # Counter is in %r15 (%edi to be exact), which we use, so move it to %r15
    movq $0, %r15
    movl (%r12), %r15d # Counter is the number of repetitions
bf_read_loop:
    movq $0, %rax           # Read flag
    movq $0, %rdi           # stdin file descriptor
    movq $1, %rdx           # max size
    subq $16, %rsp          # Allocate two bytes for temporary storage of the read value
    # when we read single byte, it is the char that we want to put into the memory
    movq %rsp, %rsi         # Address of the buffer
# TODO: correct reading of chars
    syscall
    movb (%rsp), %al      # Move the read value to the temporary register

    cmpb $0, %al           # Check if everything works as expected
    jl cannot_read_from_stdin # If there is an error, show error message and exit
    
    #cmpb $'\n', %al           # Check if we read a newline
    #je bf_read_loop           # If we did, then read again

    movb %al, (%r13)       # Load value from the temporary register to the brainfuck memory
    addq $16, %rsp          # Deallocate the temporary storage
    
    decq %r15               # Decrement the counter
    cmpq $0, %r15           # Check if we are done
    jne bf_read_loop        # If we have not read all the chars, then read the next one

    jmp looping_around_for_execution

bf_loop_start:
    addq $8, %r12 # Increment the instruction pointer anyways, so now it points to the loop end address
    cmpb $0, (%r13)         # Check if the current memory cell is zero
    jne looping_around_for_execution # If not - continue execution

    # If it is, we have pointer to the end block stored in the next cell
    movq (%r12), %r12
    addq $8, %r12 # Move the pointer to the instruction after the loop end
    jmp looping_around_for_execution # and continue execution

bf_loop_end:
    addq $8, %r12 # Increment the instruction pointer anyways, so now it points to the cell with loop start address
    cmpb $0, (%r13)         # Check if the current memory cell is zero
    je looping_around_for_execution # If it is, continue execution

    # If it is not, then we have pointer to the start loop block stored in the current cell, so move the pointer to it
    movq (%r12), %r12
    # and add 8 to it, so now it points to the instruction after the loop start
    addq $8, %r12
    jmp looping_around_for_execution # and continue execution
    
post_execution:
    # Clean up the stack
    movq %rbp, %rsp
    popq %rbp

    jmp end

# Different variants of how we can exit

end:
    mov     $60, %rax               # system call 60 is exit
    movq $0, %rdi              # we want return code 0
    jmp end_brainfuck#call exit #syscall 

fail:
    movq $1, %rdi
    mov $60, %rax
    jmp end_brainfuck#call exit #syscall

# Some error messages
# Remove the first jmp to see them
more_than_one_arg:
    movq $1, %rax           # Write flag
    movq $1, %rdi           # stdout file descriptor
    movq $50, %rdx           # Write many bytes
    movq $more_than_one_arg_message, %rsi         # pointer to the string
    syscall

    jmp fail

cannot_read_file:
    movq $1, %rax           # Write flag
    movq $1, %rdi           # stdout file descriptor
    movq $50, %rdx           # Write many bytes
    movq $cannot_read_file_message, %rsi         # pointer to the string
    syscall

    jmp fail

cannot_read_from_stdin:
    movq $1, %rax           # Write flag
    movq $1, %rdi           # stdout file descriptor
    movq $50, %rdx           # Write many bytes
    movq $cannot_read_from_stdin_message, %rsi         # pointer to the string
    syscall

    jmp fail

nothing_in_stdin:
    movq $1, %rax           # Write flag
    movq $1, %rdi           # stdout file descriptor
    movq $50, %rdx           # Write many bytes
    movq $nothing_in_stdin_message, %rsi         # pointer to the string
    syscall

    jmp fail

incomplete_loop:
    movq $1, %rax           # Write flag
    movq $1, %rdi           # stdout file descriptor
    movq $50, %rdx           # Write many bytes
    movq $incomplete_loop_message, %rsi         # pointer to the string
    syscall

    jmp fail

end_brainfuck:
    movq %rbp, %rsp
    popq %rbp
    popq %r15
    popq %r14
    popq %r13
    popq %r12
    popq %rbx
    popq %rbx
    ret


################################# JUMPTABLE 1 #################################

.text

jumptable_gen:
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_complex_zero
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_complex_exit
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_complex_start
    .quad gen_complex_end
    .quad gen_complex_mul
    .quad gen_add
    .quad gen_read
    .quad gen_sub
    .quad gen_print
    .quad gen_complex_sub_mul
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_left
    .quad gen_main_loop
    .quad gen_right
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_loop_start
    .quad gen_main_loop
    .quad gen_loop_end
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_complex_single_mul
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_complex_sub_single_mul
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop
    .quad gen_main_loop


######################### JUMPTABLE 2 ############################################
.text

jumptable:
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad bf_complex_zero
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad bf_complex_exit
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad bf_complex_start
    .quad bf_complex_end
    .quad bf_complex_mul
    .quad bf_add
    .quad bf_read
    .quad bf_sub
    .quad bf_print
    .quad bf_complex_sub_mul
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad bf_left
    .quad looping_around_for_execution
    .quad bf_right
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad bf_loop_start
    .quad looping_around_for_execution
    .quad bf_loop_end
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad bf_complex_single_mul
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad bf_complex_sub_single_mul
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution
    .quad looping_around_for_execution


################################### COMPILER EXECUTOR ########################################

# This program takes an assebmly file input, and generates an executable, giving its path in %rax, or $-1 if something failed along the way
/* vim: set filetype=gas : */

.text

compilation_enter_message: .asciz "Compilation started\n"
compilation_error_message: .asciz "Compilation failed\n"
compilation_success_message: .asciz "Compilation successful\n"

executable_enter_message: .asciz "Starting the executable...\n"

error_at_fork_msg: .asciz "Error at fork\n"

filename: .asciz "/tmp/compiled_brainfuck_138047.s"

# to compile the thing we use the following script:
# sh -c '$(which as) -o /tmp/compiled_brainfuck_138047.o /tmp/compiled_brainfuck_138047.s && $(which ld) -o /tmp/compiled_brainfuck_138047 /tmp/compiled_brainfuck_138047.o'

sh_path: .asciz "/bin/sh"

sh_arg_1: .asciz "-c"
sh_arg_2: .asciz "as -o /tmp/compiled_brainfuck_138047.o /tmp/compiled_brainfuck_138047.s 2> /dev/null && ld -o /tmp/compiled_brainfuck_138047 /tmp/compiled_brainfuck_138047.o 2> /dev/null"

sh_arg_2_rm: .asciz "rm -rf /tmp/compiled_brainfuck* 2> /dev/null"

executable_path: .asciz "/tmp/compiled_brainfuck_138047"

# The first argument is the address of the string, %rdi
# The second argument is the length of the string, %rsi
compile_from_string:
    pushq %rbp
    movq %rsp, %rbp

    movq %rdi, %r8  # Save the data address
    movq %rsi, %r9 # Save the data length

    # Create a file
    movq $85, %rax
    movq $511, %rsi
    movq $filename, %rdi
    syscall

    movq %rax, %r10 # Save the file descriptor

    # Write to the file
    movq $1, %rax
    movq %r9, %rdx
    movq %r10, %rdi
    movq %r8, %rsi
    syscall
    
    # Fork the compiler
    mov $57, %rax
    syscall # sys_fork
    and     %rax, %rax        # rax contains the PID 
# If zero - child, otherwise - parent
    js      error_at_fork   # if negative then there was an error
    jnz     parent          # childs pid returned, go to parent

run_shell:
    #mov     $1, %rax                # system call 1 is write
    #mov     $1, %rdi                # file handle 1 is stdout
    #mov     $compilation_enter_message, %rsi          # address of string to output
    #mov     $20, %rdx               # number of bytes
    #syscall  
    
    # A long preparation for the execve
    xor %rdx, %rdx 
    pushq %rdx
    leaq sh_arg_2, %r9
    pushq %r9
    leaq sh_arg_1, %r9
    pushq %r9
    leaq sh_path, %rdi
    pushq %rdi
    movq %rsp, %rsi

    mov $59, %rax # Execve 
    syscall

    # Just end the world in case we are here, as execve should kill the process
    #mov     $1, %rax                # system call 1 is write
    #mov     $1, %rdi                # file handle 1 is stdout
    #mov     $compilation_error_message, %rsi          # address of string to output
    #mov     $23, %rdx               # number of bytes
    #syscall  
    
    # Exit with code 1, as we need to tell the parent that something failed
    mov $60, %rax
    mov $1, %rdi
    syscall

parent:
    mov     %rax, %r12              # save childs pid
    
    # Wait until child finishes
    pushq $0
    mov     $61, %rax
    mov     %r12, %rdi
    mov     %rsp, %rsi
    mov     $0, %rdx
    syscall

    # Check that kiddo is dead (worked well, which means it returned 0)
    movq (%rsp), %rax
    cmp $0, %rax
    jne compilation_failed
    
    # Fork
    mov $57, %rax
    syscall # sys_fork
    and     %rax, %rax        # rax contains the PID
    # If zero - child, otherwise - parent
    
    js error_at_fork
    jnz parent_final

run_executable:
    #mov     $1, %rax                # system call 1 is write
    #mov     $1, %rdi                # file handle 1 is stdout
    #mov     $executable_enter_message, %rsi          # address of string to output
    #mov     $13, %rdx               # number of bytes
    #syscall  
    
    # A long preparation for the execve
    xor %rdx, %rdx 
    pushq %rdx
    leaq executable_path, %rdi
    pushq %rdi
    movq %rsp, %rsi

    mov $59, %rax # Execve 
    syscall

    # Exit with code 1, as we need to tell the parent that something failed
    mov $60, %rax
    mov $1, %rdi
    syscall

parent_final:
    movq %rax, %r12 # Save the childs pid

    # Wait until child finishes
    pushq $0
    mov     $61, %rax
    mov     %r12, %rdi
    mov     %rsp, %rsi
    mov     $0, %rdx
    syscall

    # now we do not really care what happened, as it should be fine anyways
    # fork
    mov $57, %rax
    syscall # sys_fork
    and     %rax, %rax        # rax contains the PID
    # If zero - child, otherwise - parent

    js error_at_fork
    jnz parent_final_final

run_rm:
    # A long preparation for the execve
    xor %rdx, %rdx 
    pushq %rdx
    leaq sh_arg_2_rm, %r9
    pushq %r9
    leaq sh_arg_1, %r9
    pushq %r9
    leaq sh_path, %rdi
    pushq %rdi
    movq %rsp, %rsi

    mov $59, %rax # Execve 
    syscall

    # Exit with code 1, as we need to tell the parent that something failed
    mov $60, %rax
    mov $1, %rdi
    syscall

parent_final_final:
    movq %rax, %r12 # Save the childs pid

    # Wait until child finishes
    pushq $0
    mov     $61, %rax
    mov     %r12, %rdi
    mov     %rsp, %rsi
    mov     $0, %rdx
    syscall

    # now we do not really care what happened, as it should be fine anyways
    jmp success

compiler_exec_end:
    # Cleanup the stack
    movq %rbp, %rsp
    popq %rbp
    ret

error_at_fork:
    mov     $1, %rax                # system call 1 is write
    mov     $1, %rdi                # file handle 1 is stdout
    mov     $error_at_fork_msg, %rsi          # address of string to output
    mov     $30, %rdx               # number of bytes
    syscall  
    jmp compiler_exec_end

compilation_failed:
    movq $1, %rax
    jmp compiler_exec_end

success:
    movq $0, %rax
    jmp compiler_exec_end


#################################### COMPILER GENERATOR ####################################

# This function takes a pointer to the compressed brainfuck representation, and pointer to the location where we want to put our output, and produces assembly code for it at the specified location
/* vim: set filetype=gas : */

.text
    _mov: .asciz "movb "
    _movb: .asciz "movb "
    _addb: .asciz "addb "
    _addq: .asciz "addq "
    _subb: .asciz "subb "
    _subq: .asciz "subq "
    _jmp: .asciz "jmp "
    _jne: .asciz "jne "
    _je: .asciz  "je "
    _mul: .asciz "mulb "
    _label: .asciz " _"
    _colon: .asciz ":\n"
    _new_line: .asciz "\n"
    _loop_start_bp: .asciz "cmpb $0,(%rbx)\nje"
    _print_1: .asciz "movq $1,%rax\nmovq $1,%rdi\nmovq $1,%rdx\nmovq %rbx,%rsi\naddq $"
    _print_2: .asciz ", %rsi\nsyscall\n"
    _read_1: .asciz "movq $0,%rax\nmovq $0,%rdi\nmovq $1,%rdx\nsubq $16,%rsp\nmovq %rsp,%rsi\nsyscall\nmovb (%rsp),%al\nmovb %al,"
    _read_2: .asciz "(%rbx)\naddq $16,%rsp\n"
    _rbx: .asciz "%rbx"
    _rbx_wrapped: .asciz "(%rbx)"
    _rbx_wrapped_nl: .asciz "(%rbx)\n"
    _intro: .asciz ".text\n.global _start\n_start:\npushq %rbp\nmovq %rsp,%rbp\nsubq $30000,%rsp\nmovq %rsp,%rbx\n"
    _outro: .asciz "movq %rbp,%rsp\npopq %rbp\nmovq $60, %rax\nmovq $0,%rdi\nsyscall\n"
    _complex_start_post: .asciz "(%rbx), %r15b\n"
    _complex_mul_1: .asciz "mulb %r15b\naddb %al, "
    _complex_mul_sub_1: .asciz "mulb %r15b\nsubb %al, "
    _complex_single_mul_1: .asciz "addb %r15b, "
    _complex_sub_single_mul_1: .asciz "subb %r15b, "
    _complex_zero_1: .asciz "movb $0, "
    _al: .asciz "%al"
compile_to_string:
    pushq %rbp              # Push base pointer to stack
    movq %rsp, %rbp         # Base pointer = stack pointer 
    
    # Save callee-saved registers
    pushq %r12
    pushq %r13
    pushq %r14
    pushq %r15
    pushq %rbx
    
    # Here is the main loop
    # Pointer to the current block - r12
    movq %rdi, %r12
    # Pointer to the output - r13
    movq %rsi, %r13
    
    # Print the intro
    movq %r13, %rdi
    movq $_intro, %rsi
    call add_line
    movq %rax, %r13

    
    movq $0, %r14 # the relative-pointer counter set to 0
    # Main loop
    subq $8, %r12
gen_main_loop:
    addq $8, %r12
    # Get the operation on the current block
    movzxb 4(%r12), %r10
    # Get the number of repetitions of the current block
    movq $0, %r15 # Clear the register
    movl (%r12), %r15d
    
    # If we are not done, jump to the suitable subroutine
    shlq $3, %r10
    movq jumptable_gen(%r10), %r10
    jmp *%r10

    # If we are here something went wrong, but i dont care
    jmp gen_main_loop

# In the assembly produced the register %rbx is the pointer to the current bf memory cell, and %rip is instruction pointer
gen_add:
    # addb v%r15b, (%rbx)
    movq %r13, %rdi
    movq $_addb, %rsi
    movl %r15d, %edx
    movq $_rbx_wrapped, %rcx
    movq %r14, %r8 # offset
    call construct_line

    movq %rax, %r13
    jmp gen_main_loop

gen_sub:
    # subb v%r15b, (%rbx)
    movq %r13, %rdi
    movq $_subb, %rsi
    movl %r15d, %edx
    movq $_rbx_wrapped, %rcx
    movq %r14, %r8 # offset
    call construct_line
    
    movq %rax, %r13
    jmp gen_main_loop

gen_right:
    # addq v%r15, %rbx
    #movq %r13, %rdi
    #movq $_addq, %rsi
    #movl %r15d, %edx
    #movq $_rbx, %rcx
    #call construct_line

    #movq %rax, %r13
    # when we move right, we actually only add the value to r14, which sets the offset for every other operation
    addq %r15, %r14

    jmp gen_main_loop

gen_left:
    # subq v%r15, %rbx
    #movq %r13, %rdi
    #movq $_subq, %rsi
    #movl %r15d, %edx
    #movq $_rbx, %rcx
    #call construct_line

    #movq %rax, %r13
    # when we move left, we actually only sub the value from r14, which sets the offset
    subq %r15, %r14
    jmp gen_main_loop

gen_print:
    # movq $1, %rax
    # movq $1, %rdi
    # movq $1, %rdx
    # movzxb (%rbx), %rsi
    # syscall
    movq %r13, %rdi
    movq $_print_1, %rsi
    call add_line
    movq %rax, %r13
    
    # print the offset
    movq %r13, %rdi
    movq %r14, %rsi
    call print_offset_wz
    movq %rax, %r13

    movq %r13, %rdi
    movq $_print_2, %rsi
    call add_line
    movq %rax, %r13
    
    decb %r15b
    cmpb $0, %r15b
    jne gen_print

    jmp gen_main_loop
# TODO: multiple reads
gen_read:
    # movq $0, %rax
    # movq $0, %rdi
    # movq $1, %rdx
    # subq $16, %rsp
    # movq %rsp, %rsi
    # syscall
    # movb (%rsp), %al
    #movb %al, (%r13)
    #addq $16, %rsp
    movq %r13, %rdi
    movq $_read_1, %rsi
    call add_line
    movq %rax, %r13
    
    # print the offset
    movq %r13, %rdi
    movq %r14, %rsi
    call print_offset_wz
    movq %rax, %r13
    
    movq %r13, %rdi
    movq $_read_2, %rsi
    call add_line
    movq %rax, %r13

    jmp gen_main_loop

# At any loop start/end we set the relative counter to 0, and then add/sub to the real counters
gen_loop_start:
    # label_xxx:
    #     cmpb $0, (%rbx)
    #     je label_yyy

    # In the next block from the loop start we have stored the address of the block after the loop end
    # Lets use it in hex form, as a xxx and yyy. We will use the same format for all labels
    # So, yyy = 8(%r12), qword; xxx = %r12, qword
    
    # resolve the situation with relative pointers
    cmpq $0, %r14
    je gen_loop_start_no_offset
    movq %r13, %rdi
    movq $_addq, %rsi
    movq %r14, %rdx
    movq $_rbx, %rcx
    movq $0, %r8
    call construct_line
    movq %rax, %r13
    # and zerofy current relative pointer
    movq $0, %r14
gen_loop_start_no_offset:

    movq %r13, %rdi
    movq %r12, %rsi
    call print_label_with_colon
    movq %rax, %r13
    
    # Next line!
    movq %r13, %rdi
    movq $_loop_start_bp, %rsi
    call add_line
    movq %rax, %r13

    # Last label!
    movq %r13, %rdi
    movq 8(%r12), %rsi
    call print_label
    movq %rax, %r13

    # and new line
    movq %r13, %rdi
    movq $_new_line, %rsi
    call add_line
    movq %rax, %r13

    # Done
    addq $8, %r12 # skip next block with address

    jmp gen_main_loop

gen_loop_end:
    #     jmp label_xxx
    # label_yyy:

    # now we have to resolve the situation with relative pointers
    cmpq $0, %r14
    je gen_loop_end_no_offset
    movq %r13, %rdi
    movq $_addq, %rsi
    movq %r14, %rdx
    movq $_rbx, %rcx
    movq $0, %r8
    call construct_line
    movq %rax, %r13
    # and zerofy current relative pointer
    movq $0, %r14
gen_loop_end_no_offset:
    movq %r13, %rdi
    movq $_jmp, %rsi
    call add_line
    movq %rax, %r13
    # Current state: jmp
    
    movq %r13, %rdi
    movq 8(%r12), %rsi
    call print_label
    movq %rax, %r13
    # Current state: jmp label_xxx

    # and new line
    movq %r13, %rdi
    movq $_new_line, %rsi
    call add_line
    movq %rax, %r13
    
    # and label
    movq %r13, %rdi
    movq %r12, %rsi
    call print_label_with_colon
    movq %rax, %r13
    

    # Done
    addq $8, %r12 # skip next block with address

    jmp gen_main_loop

# Complex operations are here
gen_complex_exit:
    # Just done with the program
    # Add null terminator
    incq %r13
    movb $0, (%r13)

    jmp done

# in complex loops no stuff with relative pointers is needed, as there are by definiton no arbitrary pointer movement
gen_complex_start:
    # We want to put the current block value into %r15
    # movb v%r14(%rbx), %r15b
    movq %r13, %rdi
    movq $_movb, %rsi
    call add_line
    movq %rax, %r13
    
    # the offset for the current variable, stored in %r14
    movq %r13, %rdi
    movq %r14, %rsi
    call print_offset_wz
    movq %rax, %r13
    
    # abd the (%rbx), %r15 part
    movq %r13, %rdi
    movq $_complex_start_post, %rsi
    call add_line
    movq %rax, %r13

    addq $8, %r12 # skip next block with address
    jmp gen_main_loop

gen_complex_end:
    # Do nothing

    addq $8, %r12 # skip next block with address
    jmp gen_main_loop

gen_complex_mul:
    # Here we want to add to the current block r15 * repetitions
    # movb repetitons, %al
    # mulb %r15b
    # addb %al, v%r14(%rbx)
    movq %r13, %rdi
    movq $_movb, %rsi
    movl %r15d, %edx
    movq $_al, %rcx
    movq $0, %r8 # offset
    call construct_line
    movq %rax, %r13

    # mulb %r15b, addb %al, 
    movq %r13, %rdi
    movq $_complex_mul_1, %rsi
    call add_line
    movq %rax, %r13

    # print the offset
    movq %r13, %rdi
    movq %r14, %rsi
    call print_offset
    movq %rax, %r13
    
    # (%rbx)
    movq %r13, %rdi
    movq $_rbx_wrapped_nl, %rsi
    call add_line
    movq %rax, %r13

    jmp gen_main_loop

gen_complex_sub_mul:
    # Here we want to subtract from the current block r15 * repetitions
    # movb repetitons, %al
    # mulb %r15b
    # addb %al, v%r14(%rbx)
    movq $_movb, %rsi
    movl %r15d, %edx
    movq $_al, %rcx
    movq $0, %r8 # offset
    call construct_line
    movq %rax, %r13

    # mulb %r15b, sub %al, 
    movq %r13, %rdi
    movq $_complex_mul_sub_1, %rsi
    call add_line
    movq %rax, %r13

    # print the offset
    movq %r13, %rdi
    movq %r14, %rsi
    call print_offset
    movq %rax, %r13
    
    # (%rbx)
    movq %r13, %rdi
    movq $_rbx_wrapped_nl, %rsi
    call add_line
    movq %rax, %r13

    jmp gen_main_loop

gen_complex_single_mul:
    # Here we want to add to the current block r15, without repetitions
    # addb %r15b, (%rbx)
    # addb %r15b, 
    movq %r13, %rdi
    movq $_complex_single_mul_1, %rsi
    call add_line
    movq %rax, %r13

    # print the offset
    movq %r13, %rdi
    movq %r14, %rsi
    call print_offset
    movq %rax, %r13

    # (%rbx) 
    movq %r13, %rdi
    movq $_rbx_wrapped_nl, %rsi
    call add_line
    movq %rax, %r13

    jmp gen_main_loop

gen_complex_sub_single_mul:
    # Here we want to add to the current block r15, without repetitions
    # subb %r15b, (%rbx)
    # subb %r15b, 
    movq %r13, %rdi
    movq $_complex_sub_single_mul_1, %rsi
    call add_line
    movq %rax, %r13

    # print the offset
    movq %r13, %rdi
    movq %r14, %rsi
    call print_offset
    movq %rax, %r13

    # (%rbx) 
    movq %r13, %rdi
    movq $_rbx_wrapped_nl, %rsi
    call add_line
    movq %rax, %r13

    jmp gen_main_loop

gen_complex_zero:
    # Here we want to set the current block to zero
    # movb $0, (%rbx)
    movq %r13, %rdi
    movq $_complex_zero_1, %rsi
    call add_line
    movq %rax, %r13

    # print the offset
    movq %r13, %rdi
    movq %r14, %rsi
    call print_offset
    movq %rax, %r13

    # (%rbx) 
    movq %r13, %rdi
    movq $_rbx_wrapped_nl, %rsi
    call add_line
    movq %rax, %r13

    jmp gen_main_loop


# End of instructions list
# Start of functions

print_offset_wz:
    # offset (relative pointer) lies in the %rsi, pointer to the current block lies in %rdi
    movq %rdi, %rax # return this thing if offset is 0
    cmpq $0, %rsi
    jge continue_printing_offset_wz
    movq $'-', (%rdi)
    incq %rdi
    neg %rsi
continue_printing_offset_wz:
    movb $'0', (%rdi)
    movb $'x', 1(%rdi)
    addq $2, %rdi

    call print_hex_to_address
    ret

print_offset:
    # offset (relative pointer) lies in the %rsi, pointer to the current block lies in %rdi
    movq %rdi, %rax # return this thing if offset is 0
    cmpq $0, %rsi
    je finish_printing_offset
    jg continue_printing_offset
    movq $'-', (%rdi)
    incq %rdi
    neg %rsi
continue_printing_offset:
    movb $'0', (%rdi)
    movb $'x', 1(%rdi)
    addq $2, %rdi

    call print_hex_to_address
finish_printing_offset:
    ret


add_line:
    pushq %rbp
    movq %rsp, %rbp
    
    # Pointer to the dest - rdi, first param
    # Pointer to the source - rsi, second param
    
add_line_loop:
    # Check that we are at the end of the string
    cmpb $0, (%rsi)
    je add_line_done
    
    # If we are not, add the current character to the dest
    movb (%rsi), %al
    movb %al, (%rdi)

    incq %rdi
    incq %rsi

    jmp add_line_loop

add_line_done:
    movq %rdi, %rax # Return the pointer to the end of the string

    movq %rbp, %rsp
    popq %rbp
    ret

construct_line:
    pushq %rbp
    movq %rsp, %rbp
    pushq %r8 # push 5th parameter

    # Pointer to the dest - rdi, first param
    # Pointer to the source - rsi, second param
construct_line_first_loop:
    # Check that we are at the end of the string
    cmpb $0, (%rsi)
    je construct_line_first_loop_done
    
    # If we are not, add the current character to the dest
    movb (%rsi), %al
    movb %al, (%rdi)
    
    incq %rdi
    incq %rsi

    jmp construct_line_first_loop

construct_line_first_loop_done:
    # Now, we have reached interesting stuff. The first thing is to render the number of repetitions, which is in %edx. How do we do that? Simple: print 8 digits in hex.
    
    movb $'$', (%rdi)
    incq %rdi

    # rdi is correct, rsi is not
    movq %rdx, %rsi # Move the number to the second param
    call print_offset
    movq %rax, %rdi

    # Now we need to add ' , ' to the dest
    movb $',', (%rdi)
    movb $' ', 1(%rdi)
    addq $2, %rdi

    # now check whether the 4th parameter rdx is 0 or not. if it is 0 - skip the offset, if it is not - print it
    popq %r8 # pop 5th parameter
    movq %r8, %rsi
    call print_offset

    # Now we need to add the last param, which is in %rcx, to the dest
construct_line_second_loop:
    # Check that we are at the end of the string
    cmpb $0, (%rcx)
    je construct_line_second_loop_done

    # If we are not, add the current character to the dest
    movb (%rcx), %al
    movb %al, (%rdi)

    incq %rdi
    incq %rcx

    jmp construct_line_second_loop
    
construct_line_second_loop_done:
    # Now we need to add '\n' to the dest, as the final thing
    movb $'\n', (%rdi)
    incq %rdi

    # Now we are completly done, and we can return the pointer to the new end of the string
    movq %rdi, %rax

    movq %rbp, %rsp
    popq %rbp
    ret

print_hex_to_address:
    movq %rdi, %r8 # Save the pointer to the start of the number
    construct_number_loop:
    # Lets take first 4 bits of the %esi, second param, and transform it into a hex digit
    movq %rsi, %rax
    andq $0xF, %rax
    # Now there is a number in %eax, which is between 0 and 15. We need to transform it into a hex digit
    cmpb $10, %al # If the number is greater or equal than 10, we need to add code of letter 'A' to it
    jge _cl_add_A_to_al
    # Otherwise we need to add code of '0'
    addb $'0', %al
    jmp _cl_al_done

_cl_add_A_to_al:
    addb $'A' - 10, %al
    
_cl_al_done:
    # Now we have the hex digit in %al, and we need to add it to the dest
    movb %al, (%rdi)
    incq %rdi
    
    # Now we need to shift the %edx to the right by 4 bits
    shrq $4, %rsi
    # And repeat the process until %rsi is 0
    cmpq $0, %rsi
    jne construct_number_loop

    # Now we have to reverse the order of digits
    # We will do it by swapping the first and the last digits, then the second and the second last, and so on
    decq %rdi
    movq %rdi, %r9 # Pointer to the end of the string
    # r8 is Pointer to the start of the string
        
_cl_reverse_loop:
    cmpq %r9, %r8
    jge _cl_reverse_done # If the pointers are equal or crossed, we are done
    
    # Otherwise, we need to swap the digits
    movb (%r9), %al
    movb (%r8), %r10b
    movb %r10b, (%r9)
    movb %al, (%r8)

    incq %r8
    decq %r9
    jmp _cl_reverse_loop

_cl_reverse_done:
#    # Now we have to return the new pointer
    incq %rdi
    movq %rdi, %rax
    ret

print_label:
    movq %rdi, %r8
    movq %rsi, %r9
    
    movq %r8, %rdi
    movq $_label, %rsi
    call add_line
    movq %rax, %r8
    # Current state: label_
    
    movq %r8, %rdi
    movq %r9, %rsi
    call print_hex_to_address
    movq %rax, %r8
    # Current state: label_1234
    
    movq %r8, %rax
    ret

print_label_with_colon:
    movq %rdi, %r8
    movq %rsi, %r9
    
    movq %r8, %rdi
    movq $_label, %rsi
    call add_line
    movq %rax, %r8
    # Current state: label_
    
    movq %r8, %rdi
    movq %r9, %rsi
    call print_hex_to_address
    movq %rax, %r8
    # Current state: label_1234
    
    movq %r8, %rdi
    movq $_colon, %rsi
    call add_line
    movq %rax, %r8
    # Current state: label_1234:
    
    movq %r8, %rax
    ret    

done:
    # Print the outro
    movq %r13, %rdi
    movq $_outro, %rsi
    call add_line
    movq %rax, %r13

    # Restore callee-saved registers
    popq %rbx
    popq %r15
    popq %r14
    popq %r13
    popq %r12
    
    movq %rbp, %rsp         # Stack pointer = base pointer
    popq %rbp               # Restore base pointer
    ret


############################ LEAF OPTIMIZATION #############################

# The leaf optimization thingy
/* vim: set filetype=gas : */
.text

# It takes as input RLE encoded data, and transforms it inplace into more efficient code

# First parameter is pointer to the start of RLE, second is pointer to the output
leaf_optimization:
    # Prologue
    pushq %rbp
    movq %rsp, %rbp

    # Push all the registers, just in case
    pushq %rbx
    pushq %r12
    pushq %r13
    pushq %r14
    pushq %r15

    # iterate over the whole code, and count the brackets.
    # At each closing bracket, check if the corresponding bracket has flag 'nlf' set. 'nlf' because 'not leaf'. 
    # If it is set, just continue like nothing happened
    # If it is not set, optimize the loop

    # Let's store pointer to the current block in RLE in r12
    movq %rdi, %r12
    movq %rsp, %r14
    
main_lo_loop:
    # Put the current symbol into r9
    movb 4(%r12), %r9b

    cmpb $'[', %r9b
    je lo_opening_bracket

    cmpb $']', %r9b
    je lo_closing_bracket

    cmpb $'$', %r9b
    je end_leaf_optimization

lo_condition_end:
    # If it is not a bracket, then just move to the next block
    addq $8, %r12

    # Repeat the loop
    jmp main_lo_loop

found_leaf:
    # Try to detect zeros
#    jmp zero_detection
#zero_detection_ret:
    
    # Count the arrows (total ptr change) in the loop
    # Simultaneously calculate the iteration step of the counter
    # Let the pointer to the inner-loop instruction be in rcx, as found leaf is called when the rcx points to the correct opening bracket.
    # Lets store the current pointer delta (arrow sum) in rbx, and the counter step in rdx
    movq %rcx, %r15 # Save the pointer to the opening bracket for future use
    movq $0, %rdx
    movq $0, %rbx
    addq $8, %rcx

lo_check_correctness_loop:
    # Check that we haven't reached the closing bracket yet
    cmpq %rcx, %r12
    je finish_checking_correctness  # If we have reached the end, break the loop

    # Save symbol in rax
    movb 4(%rcx), %al
    cmpb $'>', %al
    je lo_arrow_right
    cmpb $'<', %al
    je lo_arrow_left
    
    # If there is an input into the loop - do not optimize the loop
    cmpb $',', %al
    je lo_condition_end
    
    # If there is an output from the loop - do not optimize
    cmpb $'.', %al
    je lo_condition_end

    cmpq $0, %rbx   # Check that the arrow sum is zero
    je lo_arrow_sum_is_zero 

arrow_if_end:
    addq $8, %rcx
    jmp lo_check_correctness_loop

lo_arrow_right:
    addl (%rcx), %ebx
    jmp arrow_if_end

lo_arrow_left:
    subl (%rcx), %ebx
    jmp arrow_if_end

lo_arrow_sum_is_zero:
    cmpb $'+', %al
    je lo_plus
    cmpb $'-', %al
    je lo_minus
    jmp arrow_if_end

lo_plus:
    addl (%rcx), %edx
    jmp arrow_if_end

lo_minus:
    subl (%rcx), %edx
    jmp arrow_if_end


finish_checking_correctness:    
    cmpl $-1, %edx  # Check that the counter step is exactly -1
    jne lo_condition_end # If condition is not met -> end the optimization of the loop

    cmpl $0, %ebx    # Check that the arrow sum is zero
    jne lo_condition_end # If condition is not met -> end the optimization of the loop
    
    # If we are here, then we have a loop which can be optimized

    # The *optimization* routine is simple: we just replace brackets [] with parentheses (), + with *, - with /.    # Let's move the pointer to the [ in rax, and pointer to the ] in rbx
    movq %r15, %rax
    movq %r12, %rbx

# Replace some specific patterns with commands, currently only "!".
lo_replacement_pattern_detection:
    # Detect 0 patter: [-]:
    # Check that loop size = 1 (4 including brackets and pointer)
    movq %rax, %rcx
    addq $32, %rcx
    cmpq %rcx, %rbx
    jne lo_replacement_loop_prep # If the pattern length of loop is not 3, then just continue
    
    # Check that the only symbol in the loop is -
    movb 20(%rax), %cl # 12 because 4 is the offset, 16 is the after next block
    cmpb $'-', %cl
    jne lo_replacement_loop_prep # If the symbol is not -, then just continue

    # If all the conditions are met, then replace the loop with the command
    # replace [ with 0 and 1 repetetion
    movq $0, (%rax)
    movb $'!', 4(%rax)
    movl $1, (%rax)
    # replace -,] and pointers with empty blocks
    movq $0, 8(%rax)
    movq $0, 16(%rax)
    movq $0, 24(%rax)
    movq $0, 32(%rax)

    jmp finish_lo_replacement_loop

lo_replacement_loop_prep:
    # Not iterate over all the elements between the brackets, and replace them
    # rcx is the counter, again
    movq %rax, %rcx

lo_replacement_loop:
    # Check that we haven't reached the closing bracket yet    # Save symbol in r8
    movb 4(%rcx), %r8b
    cmpb $'[', %r8b
    je lo_replacement_opening_bracket
    cmpb $']', %r8b
    je lo_replacement_closing_bracket
    cmpb $'+', %r8b
    je lo_replacement_plus
    cmpb $'-', %r8b
    je lo_replacement_minus

lo_replacement_if_end:
    # Check if we need to exit the loop
    cmpq %rcx, %rbx
    je finish_lo_replacement_loop  # If we have reached the end, break the loop
    
    addq $8, %rcx
    jmp lo_replacement_loop


lo_replacement_opening_bracket:
    movb $'(', 4(%rcx)
    addq $8, %rcx
    jmp lo_replacement_if_end

lo_replacement_closing_bracket:
    movb $')', 4(%rcx)
    addq $8, %rcx
    jmp lo_replacement_if_end

lo_replacement_plus:
    cmpl $1, (%rcx)
    movb $'a', 4(%rcx)
    je lo_replacement_if_end
    
    movb $'*', 4(%rcx)
    jmp lo_replacement_if_end

lo_replacement_minus:
    cmpl $1, (%rcx)
    movb $'s', 4(%rcx)
    je lo_replacement_if_end

    movb $'/', 4(%rcx)
    jmp lo_replacement_if_end


finish_lo_replacement_loop:
    # Now we are probably entirely done with the loop
    jmp lo_condition_end

lo_opening_bracket:
    movq %r12, %rax
    call delay_removal
    cmpq $0, %rax
    je lo_condition_end

    # Set the flag 'nlf' for all the parent brackets, until bracket with the flag encountered
    jmp set_stack_brackets_nlf_flag 
ret_ssbnf:
    # If it is an opening bracket, then push the pointer to it to the stack, twice for the stack to be aligned
    pushq %r12
    pushq %r12

    addq $8, %r12 # Skip the block with address
    jmp lo_condition_end


lo_closing_bracket:
    # If it is a closing bracket, we can check that the corresponding bracket flag just jumping to it, as pointer to the opening bracket is in the next cell
    addq $8, %r12 # Move to the next cell
    movq (%r12), %rcx # Load the pointer to the opening bracket
    # Check that 'nlf' flag is not set
    cmpb $0, 5(%rcx)
    je found_leaf   # If so jump to subroutine 'found_leaf'
    # otherwise, do nothing, and continue
    jmp lo_condition_end

set_stack_brackets_nlf_flag:
    # pointer to the current bracket is rsp
    # r8 will be iterator
    movq %rsp, %r8
ssbnf_loop:

    cmpq %r8, %r14     # if we are at the end of the brackets list, then we are done
    je end_ssbnf      # otherwise, continue setting

    # Load the address of the current bracket block into rdx
    movq (%r8), %rdx

    cmpb $1, 5(%rdx)    # $1 is nlf flag
    je end_ssbnf        # if it is set, then we are done
    
    # otherwise, set the flag and increase the counter by 16, as the values aligned to 16 bytes
    movb $1, 5(%rdx)
    addq $16, %r8
    
    jmp ssbnf_loop
end_ssbnf:
    jmp ret_ssbnf

# In hanoi there are delays which are of form 
# [>[-]+[>[-]+[-]<-]<-]
# which is equivalent to
# 0>0>0
delay_str: .asciz "[>[-]+[-]<-]"
delay_removal:
    pushq %rcx
    pushq %rdx
    pushq %r9
    # Check that the loop is of form [>[-]+[>[-]+[-]<-]<-]
    leaq 4(%rax), %rcx 
    movq $delay_str, %rdx
    
delay_removal_loop:
    cmpb $0, (%rdx)
    je finalize_delay_removal
    
    movb (%rdx), %r9b
    cmpb %r9b, (%rcx)
    jne delay_removal_end
    incq %rdx

    cmpb $'[', (%rcx)
    je delay_removal_inc
    cmpb $']', (%rcx)
    je delay_removal_inc
    addq $8, %rcx
    jmp delay_removal_loop

delay_removal_inc:
    addq $16, %rcx
    jmp delay_removal_loop

finalize_delay_removal:
    movq $0, (%rax) #[
    movq $0, 8(%rax) #[
    movq $0, 16(%rax) #>
    movq $0, 24(%rax) #[
    movq $0, 32(%rax)#[
    movq $0, 40(%rax)#-
    movq $0, 48(%rax)#]
    movq $0, 56(%rax)#]
    movq $0, 64(%rax)#+
    movq $0, 72(%rax)#[
    movq $0, 80(%rax)#[
    movq $0, 88(%rax)#-
    movq $0, 96(%rax)#]
    movq $0, 104(%rax)#]
    movq $0, 112(%rax)#<
    movq $0, 120(%rax)#-
    movq $0, 128(%rax)#]
    movq $0, 136(%rax)#]

    movb $'0', 4(%rax)
    movl $1, (%rax)

    movb $'>', 12(%rax)
    movl $1, 8(%rax)

    movb $'0', 20(%rax)
    movl $1, 16(%rax)

    movb $'<', 28(%rax)
    movl $1, 24(%rax)

    movq $0, %rax
    popq %r9
    popq %rdx
    popq %rcx
    ret

delay_removal_end:
    movq $1, %rax
    popq %r9
    popq %rdx
    popq %rcx
    ret


end_leaf_optimization:
    # Set the rax to the pointer to the last block
    movq %r12, %rax

    # Epilogue
    popq %r15
    popq %r14
    popq %r13
    popq %r12
    popq %rbx
    
    movq %rbp, %rsp
    popq %rbp

    ret

############################# RLE ########################################

# This file provides a function rle_encode which allows to encode the string using RLE
/* vim: set filetype=gas : */

.text

# %rdi - first arg - pointer to the beginning of the raw string
# %rsi - second arg - pointer to the beginning of the output
rle_encode:
    pushq %rbp
    movq %rsp, %rbp
    pushq %rbx
    
    # The block structure is as follows:
    # [4 bytes] - number of repetitions
    # [1 byte] - command
    # [3 bytes] - reserved (padding to 8 bytes)

    # Let rdi be the pointer to the current character of the raw string
    # Let rsi be the pointer to the current block of the output
    
rle_encode_loop_first_char_search:
    # If the current character is an incrorrect one, increase the %rdi
    movb (%rdi), %al
    
    cmpb $'+', %al
    je rle_encode_loop_char_continue
    cmpb $'-', %al
    je rle_encode_loop_char_continue
    cmpb $'.', %al
    je rle_encode_loop_char_continue
    cmpb $',', %al
    je rle_encode_loop_char_continue
    cmpb $'[', %al
    je rle_encode_loop_char_continue
    cmpb $']', %al
    je rle_encode_loop_char_continue
    cmpb $'<', %al
    je rle_encode_loop_char_continue
    cmpb $'>', %al
    je rle_encode_loop_char_continue
    
    # If none of the conditions met - just skip the currect character
    incq %rdi
    jmp rle_encode_loop_first_char_search
    
    # Now we will iterate over all the characters in the raw string
rle_encode_loop:
    # increase the character ptr %rdi
    incq %rdi
    movb (%rdi), %al
rle_encode_loop_char_continue:

    cmpb $'+', %al
    je rle_encode_loop_continue
    cmpb $'-', %al
    je rle_encode_loop_continue
    cmpb $'.', %al
    je rle_encode_loop_continue
    cmpb $',', %al
    je rle_encode_loop_continue
    cmpb $'[', %al
    je rle_encode_open_bracket
    cmpb $']', %al
    je rle_encode_closed_bracket
    cmpb $'<', %al
    je rle_encode_loop_continue
    cmpb $'>', %al
    je rle_encode_loop_continue
    cmpb $0, %al
    je rle_encode_loop_end
    
    # If none of the conditions met - just skip the currect character
    jmp rle_encode_loop
    
rle_encode_loop_continue:
    # Check whether the current character is the same as in the current block
    movb 4(%rsi), %bl
    cmpb %bl, %al
    jne rle_encode_loop_new_block # If not - create a new block
    # Otherwise increase the counter by one and continue
    incl (%rsi)
    jmp rle_encode_loop

rle_encode_loop_new_block:
    # Create a new block
    addq $8, %rsi
    movq $0, (%rsi)
    movb %al, 4(%rsi)
    movl $1, (%rsi)
    jmp rle_encode_loop


rle_encode_open_bracket:
    addq $8, %rsi # Add 8 to rsi so now it points directly to the bracket block
    
    # Setup current block
    movq $0, (%rsi)
    movb $'[', 4(%rsi)
    movl $1, (%rsi)

    # Save the current address of the block
    pushq %rsi

    # Allocate one additional quad after the current block
    addq $8, %rsi
    movq $0, (%rsi) # Clean it up
    
    # Create a new block
    jmp rle_encode_loop

rle_encode_closed_bracket:
    addq $8, %rsi # Add 8 to rsi so now it points directly to the bracket block
    
    # Setup current block
    movq $0, (%rsi)
    movb $']', 4(%rsi)
    movl $1, (%rsi)

    # Restore the address of the block
    popq %rdx
    
    # Put the current block address into the previously allocated block after open bracket
    movq %rsi, 8(%rdx)
    
    
    # Put the open bracket block address after current block
    addq $8, %rsi
    movq $0, (%rsi) # Clean it up
    movq %rdx, (%rsi)

    jmp rle_encode_loop


rle_encode_loop_end:
    # Add '$' as the last block
    addq $8, %rsi
    movq $0, (%rsi)
    movb $'$', 4(%rsi)
    movl $1, (%rsi)
    
    # Return the last address of the output, which is rsi + 8
    addq $8, %rsi
    movq %rsi, %rax

    popq %rbx
    movq %rbp, %rsp
    popq %rbp
    ret
    
